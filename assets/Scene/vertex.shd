#version 450

layout(location = 0) in vec3 vPosition;
in vec3 vNormal;
in vec3 uv;

uniform sampler2DArray textureArray;

uniform vec3 vColor;
uniform mat4 worldToProj_matrix;
uniform vec3 camera;
uniform uint dataSize;

uniform vec3 lightPositions[1500];  // Assuming a maximum number of lights
uniform vec3 lightColor;
uniform float lightIntensity;
uniform int numLights;  // Number of active lights

out vec3 color;
out float a;

const int MAX_COLLISIONS = 5;

//collisions will hold the index of the nbVertices in data
//distances will hold the distances of each sphere to help the sorting
uint[MAX_COLLISIONS] collisions;
float[MAX_COLLISIONS] distances;

layout(std430, binding = 0) buffer MyBuffer {
    float data[];
};

struct CollisionData {
    vec3 vertex;
    vec3 color;
};

vec3 checkCollisionTriangle(vec3 v1, vec3 v2, vec3 v3, vec3 ray) {
    const float EPSILON = 0.0001;

    //we get vector from camera center to triangle edges
    vec3 edge1 = v2 - v1;
    vec3 edge2 = v3 - v1;

    vec3 h = cross(ray, edge2);
    float a = dot(edge1, h);

    if (abs(a) < EPSILON){
        return vec3(0.0);
    }

    float f = 1.0 / a;
    vec3 s = ray - v1;
    float u = dot(s,h)*f;
    if (u < 0.0 || u > 1.0){
        return vec3(0.0);
    }

    vec3 q = cross(s, edge1);
    float v = f * dot(ray, q);

    // Check if the intersection point is outside the triangle
    if (v < 0.0 || u + v > 1.0) {
        return vec3(0.0); // Return zero vector indicating no intersection
    }

    float t = f * dot(edge2, q);
    if (t > EPSILON){
        vec3 intersectionPoint = v1 + u * edge1 + v * edge2;
        return intersectionPoint;
    }else{
        return vec3(0.0);
    }
}

bool checkSphereCollision(vec3 spherePosition, float radius, vec3 ray) {
    vec3 oc = vPosition - spherePosition;
    float a = dot(ray, ray);
    float b = 2.0 * dot(oc, ray);
    float c = dot(oc, oc) - radius * radius;
    float discriminant = b * b - 4.0 * a * c;

    if (discriminant < 0.0) {
        return false;  // No collision
    }

    float sqrtDiscriminant = sqrt(discriminant);
    float t1 = (-b - sqrtDiscriminant) / (2.0 * a);
    float t2 = (-b + sqrtDiscriminant) / (2.0 * a);

    if (t1 >= 0.0 || t2 >= 0.0) {
        return true;  // Collision detected
    }

    return false;  // No collision
}

void insert(float distance, uint index, int size){
    if (distance > distances[size-1])
        return;

    int insertIndex = 0;
    // Find the index to insert the value
    for (int i = 0; i < size; i++) {
        if (distances[i] > distance) {
            insertIndex = i;
            break;
        }
        insertIndex = i + 1;
    }

    // Shift elements to make room for the new value
    for (int i = size - 1; i >= insertIndex; i--) {
        distances[i] = distances[i - 1];
        collisions[i] = collisions[i - 1];
    }

    // Insert the value at the determined index
    distances[insertIndex] = distance;
    collisions[insertIndex] = index;
}

void bubbleSort(int size) {
    for (int i = 0; i < size - 1; ++i) {
        for (int j = 0; j < size - i - 1; ++j) {
            if (distances[j] > distances[j + 1]) {
                //sort distances array
                float temp = distances[j];
                distances[j] = distances[j + 1];
                distances[j + 1] = temp;

                //sort indexes array
                uint temp2 = collisions[j];
                collisions[j] = collisions[j + 1];
                collisions[j + 1] = temp2;
            }
        }
    }
}

float distance(vec3 p1, vec3 p2){
    vec3 diff = p1 - p2;
    return length(diff);
}

bool checkIsShadow(vec3 ray, vec3 vertex){

    //get all the sphere in collision with reflection
    //we keep only 10 of them, which are the 10 closest to vertex position
    uint i = 0;
    int nbCollisions = 0;
    while (i < dataSize) {
        vec3 nodeCenter = vec3(data[i],data[i+1],data[i+2]);
        float nodeRadius = data[i+3];
        if (checkSphereCollision(nodeCenter, nodeRadius, ray)){
            float dist = distance(vertex, nodeCenter);
            if (nbCollisions == 10){
                bubbleSort(MAX_COLLISIONS);
            }
            if (nbCollisions < 10){
                collisions[nbCollisions] = i+4;
                distances[nbCollisions] = dist;
            }else{
                insert(dist, i+4, MAX_COLLISIONS);
            }
            nbCollisions++;
        }
        i += 5 + uint(data[i+4]);
    }

    for (uint i=0; i < MAX_COLLISIONS; i++){
        //we get the index where the vertices start in data
        //and how much of them we have
        float nbVertices = data[collisions[i]];
        bool foundIntersection = false;
        for (uint j = 0; j < nbVertices; j+=9){
            uint index = collisions[i]+1+j;
            vec3 v1 = vec3(data[index], data[index + 1], data[index + 2]);
            vec3 v2 = vec3(data[index + 3], data[index + 4], data[index + 5]);
            vec3 v3 = vec3(data[index + 6], data[index + 7], data[index + 8]);

            vec3 collisionPoint = checkCollisionTriangle(v1, v2, v3, ray);

            if (length(collisionPoint) > 0.0) {
                return true;
            }
        }
    }
    return false;
}

CollisionData checkCollision(vec3 vertex, vec3 normal) {
    vec3 cameraToVertex = vertex - camera;
    vec3 reflectedDirection = normalize(cameraToVertex - normal * 2.0 * dot(cameraToVertex, normal));
    vec3 reflected_position = vec3(0.0);

    //get all the sphere in collision with reflection
    //we keep only 10 of them, which are the 10 closest to vPosition
    uint i = 0;
    int nbCollisions = 0;
    while (i < dataSize) {
        vec3 nodeCenter = vec3(data[i],data[i+1],data[i+2]);
        float nodeRadius = data[i+3];
        if (checkSphereCollision(nodeCenter, nodeRadius, reflectedDirection)){
            float dist = distance(vPosition, nodeCenter);
            if (nbCollisions == 10){
                bubbleSort(MAX_COLLISIONS);
            }
            if (nbCollisions < 10){
                collisions[nbCollisions] = i+4;
                distances[nbCollisions] = dist;
            }else{
                insert(dist, i+4, MAX_COLLISIONS);
            }
            nbCollisions++;
        }
        i += 5 + uint(data[i+4]);
    }

    CollisionData collision;
    //now we find the collision between the reflected ray nd triangles
    //in one of the sphere we sorted precedently
    for (i=0; i < MAX_COLLISIONS; i++){
        //we get the index where the vertices start in data
        //and how much of them we have
        float nbVertices = data[collisions[i]];
        bool foundIntersection = false;
        for (uint j = 0; j < nbVertices; j+=18){
            uint index = collisions[i]+1+j;
            vec3 v1 = vec3(data[index], data[index + 1], data[index + 2]);
            vec3 uv1 = vec3(data[index + 3], data[index + 4], data[index + 5]);
            vec3 v2 = vec3(data[index + 6], data[index + 7], data[index + 8]);
            vec3 uv2 = vec3(data[index + 9], data[index + 10], data[index + 11]);
            vec3 v3 = vec3(data[index + 12], data[index + 13], data[index + 14]);
            vec3 uv3 = vec3(data[index + 15], data[index + 16], data[index + 17]);

            vec3 collisionPoint = checkCollisionTriangle(v1, v2, v3, reflectedDirection);

            if (length(collisionPoint) > 0.0 && (length(reflected_position) == 0.0 || length(collisionPoint - vertex) < length(reflected_position - vertex))) {
                reflected_position = collisionPoint;
                foundIntersection = true;

                //we take the average color of the triangle
                vec3 c1 = texture(textureArray, uv1).xyz;
                vec3 c2 = texture(textureArray, uv2).xyz;
                vec3 c3 = texture(textureArray, uv3).xyz;
                collision.color = (c1+c2+c3)/3;
                collision.vertex = reflected_position;
            }
        }
        if (foundIntersection)
        break;
    }

    return collision;
}

vec3 applyDiffusionAndSpecular(vec3 position){
    vec3 normal = normalize(vNormal);
    vec3 ray = normalize(vPosition - camera);
    vec3 reflected_ray = reflect(ray, normal);

    vec3 totalLight = vec3(0.0);
    vec3 center = vec3(0.0);

    //we get diffusion
    for (int i = 0; i < numLights; i++) {
        vec3 light_dir = normalize(lightPositions[i] - vPosition);

        float coefDiffuse = clamp(dot(normal, light_dir), 0, 1) * lightIntensity;
        float coefSpecular = clamp(dot(reflected_ray, light_dir), 0, 1) * lightIntensity;
        float coef = coefDiffuse + pow(coefSpecular,10);

        totalLight += coef * lightColor;
        center += lightPositions[i];
    }
    center /= float(numLights);

    /*if(checkIsShadow(center-position, position)){
        return vec3(0.0,0.0,1.0);
    }else {
        return totalLight;
    }*/
    return totalLight;
}

vec3 applyReflection(vec3 uvColor){
    vec3 res = applyDiffusionAndSpecular(vPosition)*uvColor;
    CollisionData reflection = checkCollision(vPosition, vNormal);
    if (vPosition.y < 0){
        //res += applyDiffusionAndSpecular(reflection.vertex)*reflection.color;
    }
    return res;
}

void main() {
    vec4 uvColor;
    if (uv.z != -1){
        uvColor = texture(textureArray, uv);
    }else{
        uvColor = vec4(1.0,1.0,0.0,1.0);
    }
    color = applyReflection(uvColor.xyz);
    //color = uvColor.xyz;
    a = uvColor.a;
    gl_Position = worldToProj_matrix * vec4(vPosition, 1.0);
}